# Lab 01: "Hello, World!" Program with Cargo

## Introduction & Goal

This lab covers the creation and execution of a basic "Hello, World!" program in Rust. It focuses on the fundamental workflow using Rust's package manager and build tool, `cargo`.

The primary learning objective is to understand the basic structure of a Rust executable project, write a minimal program, and use `cargo` to compile and run it.

By the end of this lab:
*   You will be able to create a new Rust project using `cargo`.
*   You will understand the purpose of the `main` function.
*   You will use the `println!` macro to print text to the console.
*   You will compile and run your Rust program using `cargo run`.

## Scenario

To begin working with Rust, it's necessary to verify the installation and understand the process of creating, compiling, and running a program. The standard "Hello, World!" example serves this purpose.

Rust's toolchain, particularly `cargo`, facilitates project setup, compilation, and execution. `cargo` handles project creation, dependency management, building, and running, streamlining the development process.

## Prerequisites

*   **Software:**
    *   Rust toolchain (rustc, cargo) installed. The lab uses `edition = "2021"`. Ensure `rustc` version 1.56 or newer is installed.
    *   A text editor or IDE (e.g., VS Code, Sublime Text, Vim, Emacs).
    *   Access to a terminal or command prompt.
*   **Knowledge:** Basic command-line usage (navigating directories, running commands) and text file editing. No prior Rust experience is required.
*   **Setup Verification:** Open your terminal or command prompt and run the following commands to confirm the Rust installation:
    ```bash
    rustc --version
    cargo --version
    ```
    Output indicating the installed versions should appear. If errors occur, refer to the official Rust installation guide: [https://www.rust-lang.org/tools/install](https://www.rust-lang.org/tools/install)

## Setup Instructions

1.  Create a new Rust project using `cargo`. Open a terminal, navigate to your projects directory, and run:
    ```bash
    cargo new hello_world --edition 2021
    ```
    *   `cargo new` creates a new Rust project structure.
    *   `hello_world` is the project's name; a directory with this name will be created.
    *   `--edition 2021` specifies the Rust edition.
2.  Navigate into the project directory:
    ```bash
    cd hello_world
    ```
3.  No external dependencies or additional setup steps are needed for this example.

## Lab Steps (Iterative Development)

**Step 1: Examine the Initial Project Structure**

*   **Task:** Review the files generated by `cargo`.
*   **Action:** Use a file explorer or a command like `ls` (Linux/macOS) / `dir` (Windows) in the `hello_world` directory. The key items are:
    *   `Cargo.toml`: The project manifest file (metadata, dependencies).
    *   `src`: The source code directory.
    *   `src/main.rs`: The main source file for the executable.
    *   `.gitignore`: Default Git ignore file.
*   **Explanation:** `cargo` establishes a standard project layout. Source code resides in `src`. `Cargo.toml` manages project configuration and dependencies.
*   **Verification:** Familiarize yourself with the file structure.

**Step 2: Understand the `main` function and `println!`**

*   **Task:** Open `src/main.rs` in a text editor and examine the default code.
*   **Code Implementation:** The content of `src/main.rs`:
    ```rust
    fn main() {
        println!("Hello, world!");
    }
    ```
*   **Explanation:**
    *   `fn main()`: Defines the `main` function, the entry point for executable Rust programs. `fn` declares a function. `()` indicates no parameters. `{}` encloses the function body.
    *   `println!("Hello, world!");`: Prints text to the console.
        *   `println!` is a Rust macro (indicated by `!`). Macros perform compile-time code generation. `println!` handles printing to standard output, appending a newline.
        *   `"Hello, world!"` is a string literal representing the text to be printed.
        *   `;` terminates the statement.
*   **Verification:** Read and understand the code structure.

**Step 3: Run the Program**

*   **Task:** Compile and execute the program using `cargo`.
*   **Action:** Ensure the terminal is in the `hello_world` directory. Run:
    ```bash
    cargo run
    ```
*   **Explanation:**
    *   `cargo run` compiles the Rust source code into an executable binary (if changes occurred or it's the first build). The output typically goes to `target/debug/`. You'll see compilation status messages.
    *   After successful compilation, `cargo run` executes the compiled program.
*   **Verification:** The following output should appear in the terminal:
    ```
    Hello, world!
    ```
    This confirms the program compiled and ran as expected.

**Step 4: Modify the Output**

*   **Task:** Change the text printed by the program.
*   **Code Implementation:** Edit `src/main.rs`. Modify the string literal within the `println!` macro call:
    ```rust
    // In src/main.rs:
    fn main() {
        // Modify the text inside the quotes.
        println!("Rust execution successful.");
    }
    ```
*   **Explanation:** The string literal passed to `println!` determines the output. Save the file after editing.
*   **Verification:** Optionally, run `cargo check`. This command verifies the code compiles without producing an executable, providing faster error feedback. It should finish without errors if the syntax is correct.

**Step 5: Re-run the Program**

*   **Task:** Compile and run the modified program.
*   **Action:** In the terminal (within the `hello_world` directory), run:
    ```bash
    cargo run
    ```
*   **Explanation:** `cargo` detects changes to source files and recompiles as needed before executing the program.
*   **Verification:** The new message should be printed to the terminal:
    ```
    Rust execution successful.
    ```

## Running the Application / Testing

The primary command used in this lab to compile and run the application is `cargo run`.

The expected output is the string provided to the `println!` macro (e.g., `Hello, world!` initially, or the modified text later).

**Other relevant Cargo commands:**
*   `cargo check`: Checks code for compilation errors without building an executable. Useful for quick syntax checks.
*   `cargo build`: Compiles the project and creates the executable (e.g., in `target/debug/`) without running it. Use `cargo build --release` for optimized release builds (output in `target/release/`).

**(Optional) Testing:** While not demonstrated here due to the program's simplicity, larger Rust projects utilize test functions marked with `#[test]`. Tests are typically run using the `cargo test` command.

## Key Concepts Review

*   **`cargo new`**: Creates a standard Rust project structure.
*   **`Cargo.toml`**: The project manifest file for configuration and dependencies.
*   **`src/main.rs`**: Default source file for Rust executables.
*   **`fn main()`**: The required entry point function for executable programs.
*   **`println!`**: Macro for printing a line of text to standard output.
*   **`cargo run`**: Compiles and executes the project.
*   **`cargo check`**: Checks code for errors without a full build.
*   **`cargo build`**: Compiles the project without running it.

## (Optional) Challenges / Next Steps

*   Modify `src/main.rs` to print multiple lines by using `println!` more than once.
*   Experiment with printing numbers using formatted output: `println!("Value: {}", 42);`. Observe the result.
*   Consult the official Rust Programming Language book (Chapters 1 and 2) for further introductory material: [https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/)

## (Optional) Troubleshooting

*   **`error: cannot find function `main` in this scope`**: Ensure `fn main()` is correctly defined in `src/main.rs`.
*   **`error: unresolved macro `println` / cannot find macro `println!`** : Verify the spelling and the presence of the exclamation mark: `println!`.
*   **`error: could not find `Cargo.toml`...`**: Make sure `cargo` commands are executed from within the project's root directory (`hello_world`). Use `cd` to navigate if necessary.
*   **Syntax errors (missing `;`, mismatched `{}`/`()`/`[]`)**: Review the code carefully for typos. `cargo check` often provides specific error messages.

## Conclusion

This lab demonstrated the process of creating, compiling, and running a basic Rust program using `cargo`. It covered the roles of `main.rs`, `Cargo.toml`, the `main` function, and the `println!` macro. This forms the basis for developing more complex applications in Rust.

## (Optional) Final Solution Code

Final code for `src/main.rs` (assuming the modification from Step 4):

```rust
// Final Code for src/main.rs
fn main() {
    println!("Rust execution successful.");
}
```

## Check Questions (To Test Understanding)

1.  What is the purpose of the `fn main()` line in `src/main.rs`?
2.  Why is `println!` used with an exclamation mark (`!`)?
3.  What are the two primary actions performed by the `cargo run` command?
4.  In which directory are source code files typically placed within a Cargo project?
5.  Which file is used to declare external library dependencies for a Rust project?

## Detailed Answers to Check Questions

1.  `fn main()` defines the **main function**, which serves as the **entry point** for any executable Rust program. Execution begins within the body (`{}`) of this function.
2.  The exclamation mark `!` indicates that `println` is a **Rust macro**. Macros operate during compilation to generate code, offering capabilities beyond regular functions, such as handling variable numbers of arguments for formatting.
3.  `cargo run` performs two main actions:
    *   **Compile:** It invokes the Rust compiler (`rustc`) to translate source code into machine code, producing an executable file (typically in `target/debug/`). This step may be skipped if the source hasn't changed since the last compilation.
    *   **Execute:** After successful compilation, it runs the resulting executable program.
4.  Source code files (`.rs`) are typically located in the **`src` directory** at the root of a Cargo project.
5.  External library dependencies (crates) are declared in the **`Cargo.toml`** file, usually listed under the `[dependencies]` section.